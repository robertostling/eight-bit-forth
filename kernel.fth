.( COMPILING ASSEMBLER )
: ,2 , , ;
: ,3 , , , ;
( USE WITH IMM )
: ORA 0 ;
: ANDA 20 ;
: EORA 40 ;
: ADC 60 ;
: STA 80 ;
: LDA A0 ;
: CMP C0 ;
: SBC E0 ;
( USE WITH IMPL )
: ASL 1 ;
: ROL 21 ;
: LSR 41 ;
: ROR 61 ;
( USE WITH NEITHER )
: DEC C1 ;
: INC E1 ;
( ADDRESSING MODES )
: IMPL 9 + , ;
: IMM 9 + ,2 ;
: ADR D + ,3 ;
: ZP 5 + ,2 ;
: (X) 1 + ,2 ;
: (Y) 11 + ,2 ;
: ZP,X 15 + ,2 ;
: ADR,Y 19 + ,3 ;
: ADR,X 1D + ,3 ;
( BRANCHING )
: BPL 10 ,2 ;
: BMI 30 ,2 ;
: BVC 50 ,2 ;
: BVS 70 ,2 ;
: BCC 90 ,2 ;
: BCS B0 ,2 ;
: BNE D0 ,2 ;
: BEQ F0 ,2 ;
: BRK 00 , ;
: JSR 20 ,3 ; 
: RTI 40 , ;
( RTS HAS BUILT-IN OPTIMIZING WORD )
: JMP 4C ,3 ;
: JMPI 6C ,3 ;
: NOP EA , ;
: JAM 02 , ;
( ZERO-OPERAND INSTRUCTIONS )
: PHP 08 , ;
: CLC 18 , ;
: PLP 28 , ;
: SEC 38 , ;
: PHA 48 , ;
: CLI 58 , ;
: PLA 68 , ;
: SEI 78 , ;
: DEY 88 , ;
: TYA 98 , ;
: TAY A8 , ;
: CLV B8 , ;
: INY C8 , ;
: CLD D8 , ;
: INX E8 , ;
: SED F8 , ;
: TXA 8A , ;
: TXS 9A , ;
: TAX AA , ;
: TSX BA , ;
: DEX CA , ;
( VARIOUS INSTRUCTIONS WITH NON-UNIFORM
  ADDRESSING MODES )
: LDXIMM A2 ,2 ;
: LDXZP A6 ,2 ;
: LDYIMM A0 ,2 ;
: STYZP 84 ,2 ;
: STYZP,X 94 ,2 ;
: LDYZP A4 ,2 ;
: LDYZP,X B4 ,2 ;
: STYADR 8C ,3 ;
: LDYADR AC ,3 ;
: LDYADR,X BC ,3 ;
: STXZP 86 ,2 ;
: STXZP,Y 96 ,2 ;
: STXADR 8E ,3 ;
: CPYIMM C0 ,2 ;
: CPXIMM E0 ,2 ;
: CPYZP C4 ,2 ;
: CPXZP E4 ,2 ;
: CPYADR CC ,3 ;
: CPXADR EC ,3 ;
: BITZP 24 ,2 ;
: BITADR 2C ,3 ;
.( ASSEMBLING COMPILER )
: STACK> CE ;
: STACK-1 CD FF ;
: STACK STACK> 0 ;
: SBOX> CD ;
: ZHERE 2 ;
: ZLAST 4 ;
: ZINPUT 6 ;
: ZEND 8 ;
: ZSTATE C ;
: ZOPTIMIZE D ;
: ZTASK E ;
: ZTEMP 13 ;
: ZSAVE 1E ;
: ZMREG 20 ;
: ZNREG 22 ;
( TEMP ACCESS MACROS )
: T ZTEMP ;
: T+ ZTEMP + ;
: A>T+ T+ STA ZP ;
: T+>A T+ LDA ZP ;
: A>T T STA ZP ;
: T>A T LDA ZP ;
( STACK OPERATIONS AND MACROS )
: SWAP [
  STACK LDA ADR,X
  PHA
  STACK> 1 LDA ADR,X
  STACK STA ADR,X
  PLA
  STACK> 1 STA ADR,X ] ;
( NOTE: 1-BASED ADDRESSING )
: S>A STACK> SWAP FF +  LDA ADR,X ;
: A>S STACK> SWAP FF +  STA ADR,X ;
: >A STACK LDA ADR,X  INX ;
: A> DEX  STACK STA ADR,X ;
( SAME AS >A BUT SETS FLAGS AND COSTS
  1 MORE CYCLE )
: PRE>A INX  STACK-1 LDA ADR,X ;
: TOS>A 1 S>A ;
: A>TOS 1 A>S ;
: NOS>A 2 S>A ; 
: A>NOS 2 A>S ;
: #A>TOS LDA IMM  A>TOS ;
( COMPILER WORDS )
: IMMEDIATE [
  2 LDYIMM
  80 LDA IMM
  ZLAST ORA (Y)
  ZLAST STA (Y) ] ;
: ON FF ;
: OFF 0 ;
: COMPILING [ ZSTATE LDA ZP  A> ] ;
: COMPILER [ >A  ZSTATE STA ZP ] ;
: SO PRE>A 1 BNE RTS ; IMMEDIATE
: SKIP PRE>A 1 BEQ RTS ; IMMEDIATE
( STACK OPERATIONS )
: DUP [ TOS>A A> ] ;
: DROP [ INX ] ;
: OVER [ NOS>A A> ] ;
: OOVER [ 3 S>A A> ] ;
: NIP [ TOS>A A>NOS INX ] ;
: SP@ [ TXA A> ] ;
: SP! [ >A TAX ] ;
: RP@ [
  TXA PHA TSX TXA TAY PLA TAX TYA A>
  ] ;
: RP! [
  TXA TAY  TOS>A TAX TXS
  TYA TAX INX ] ;
: >R >A PHA ; IMMEDIATE
: R> PLA A> ; IMMEDIATE
: R>DROP PLA ; IMMEDIATE
: R@ PLA PHA A> ; IMMEDIATE
: -ROT [
  TOS>A PHA
  NOS>A A>TOS
  3 S>A A>NOS
  PLA 3 A>S ] ;
: ROT -ROT -ROT ;
: ?DUP [ TOS>A  1 BNE  RTS  A> ] ;
: 1+ [ STACK INC ADR,X ] ;
: 1- [ STACK DEC ADR,X ] ;
: 2* [ STACK ASL ADR,X ] ;
: 2/ [ STACK LSR ADR,X ] ;
: 2*W [
  STACK ASL ADR,X
  STACK> 1 ROL ADR,X ] ;
: DUPW OVER OVER ;
: OVERW [ 4 S>A A>  4 S>A A> ] ;
: SWAPW OVERW [
  3 S>A 5 A>S  4 S>A 6 A>S
  TOS>A 3 A>S  NOS>A 4 A>S  INX INX ] ;
( NEEDED EARLY, REST DEFINED BELOW )
: +W [
  CLC
  3 S>A  STACK> 0 ADC ADR,X  3 A>S
  4 S>A  STACK> 1 ADC ADR,X  4 A>S
  INX INX ] ;
( ZERO-PAGE MACROS )
: >ZPW ( ZP -- )
  DUP  >A STA ZP  >A 1+ STA ZP ;
: ZP>W ( ZP -- )
  DUP  1+ LDA ZP A>  LDA ZP A> ;
: +ZPW ( ZP N -- )
  LDA IMM  CLC  DUP ADC ZP  DUP STA ZP
  2 BCC  1+ INC ZP ;
: -ZPW ( ZP N -- )
  OVER LDA ZP  SEC  SBC IMM  DUP STA ZP
  2 BCS  1+ DEC ZP ;
: 1+ZPW ( ZP -- )
  DUP  INC ZP  2 BNE  1+ INC ZP ;
( COMPILER WORDS )
: HERE 0 ZHERE ;
: HERE@ [ ZHERE LDA ZP  A> ] ;
: HERE@W
  [ ZHERE 1 + LDA ZP  A> ] HERE@ ;
: HERE!W [
  >A  ZHERE STA ZP
  >A  ZHERE 1 + STA ZP ] ;
: >CODE 0 3 +W ;
: >FLAGS 0 2 +W ;
: >LAST ;
( USED FOR HOT-SWAPPING, SEE MAKE ) 
: MAKER HERE@W 0 3 +W JMP ; IMMEDIATE
( HANDLE BACKWARD REFERENCES WITH
  CONDITIONAL BRANCHING OPS )
: KERNAL-EMIT [ >A  FF D2 JSR ] ;
: EMIT MAKER KERNAL-EMIT ;
: SPACE 20 EMIT ;
: CR 0D EMIT ;
: HEXDIGIT [
  TOS>A
  0F ANDA IMM
  0A CMP IMM
  2 BCC
  6 ADC IMM
  30 ADC IMM
  A>TOS ] ;
: .H
  DUP 2/ 2/ 2/ 2/ HEXDIGIT EMIT
  HEXDIGIT EMIT ;
: . .H SPACE ;
: .W SWAP .H .H SPACE ;
: = [
  >A  STACK CMP ADR,X  6 BEQ
  00 #A>TOS  RTS
  FF #A>TOS ] ;
( MEMORY MANIPULATION )
: S>TW NOS>A 1 A>T+  TOS>A 0 A>T+ ;
: @ [ S>TW  0 LDYIMM
  T LDA (Y)
  INX A>TOS ] ;
: @W [ S>TW  0 LDYIMM
  T LDA (Y)  A>TOS  INY
  T LDA (Y)  A>NOS ] ;
: ! [ S>TW  INX INX  0 LDYIMM
  >A  T STA (Y) ] ;
: !W ! [ INY  >A  T STA (Y) ] ;
: +! [ S>TW  INX INX  0 LDYIMM
  >A  CLC T ADC (Y)  T STA (Y) ] ;
: +!W +! [
  INY >A  T ADC (Y)  T STA (Y) ] ;
( ARITHMETIC )
: ALUOP ( OP - )
  NOS>A  STACK> SWAP 0 SWAP ADR,X
  INX A>TOS ;
: - [ SEC SBC ALUOP ] ;
( : + [ CLC ADC ALUOP ] ; )
: OR [ ORA ALUOP ] ;
: XOR [ EORA ALUOP ] ;
: AND [ ANDA ALUOP ] ;
: ALUOPW ( OP - )
  DUP
  3 S>A
  STACK> SWAP 0 SWAP ADR,X  3 A>S
  4 S>A
  STACK> SWAP 1 SWAP ADR,X  4 A>S
  INX INX ;
: ORW [ ORA ALUOPW ] ;
: XORW [ EORA ALUOPW ] ;
: ANDW [ ANDA ALUOPW ] ;
: -W [ SEC SBC ALUOPW ] ;
( : +W [ CLC ADC ALUOPW ] ; )
: 1+W [
  STACK INC ADR,X
  3 BNE
  STACK> 1 INC ADR,X ] ;
( COMPARISON OPERATORS )
: TRUE FF ;
: FALSE 0 ;
: COMPOP ( OPCODE -- )
  TOS>A  , 6 ,
  FALSE #A>TOS RTS  TRUE #A>TOS ;
: 0= [ F0 COMPOP ] ;
: NOT 0= ;
: 0< [ 30 COMPOP ] ;
: 0>= [ 10 COMPOP ] ;
: 0<> [ D0 COMPOP ] ;
: 0> DUP 0>= SWAP 0<> AND ;
: 0<= DUP 0< SWAP 0= OR ;
: < - 0< ;
: > - 0> ;
: <= - 0<= ;
: >= - 0>= ;
( : = - 0= ; )
: <> - 0<> ;
: <W -W DROP 0< ;
: >=W -W DROP 0>= ;
: 0=W OR 0= ;
: 0<>W OR 0<> ;
: =W -W 0=W ;
: <>W -W 0<>W ;
: 0<W DROP 0< ;
( WORD HEADER OPERATIONS )
: >NAME
  DUPW 0 2 +W @ 1F AND  DUP >R
  0 SWAP -W  R> ;
: TAIL;
  ' >CODE JMP  OFF COMPILER ; IMMEDIATE
: JUMP ' >CODE JMP ;
: CALL ' >CODE JSR ;
( BACKWARD REFERENCES, 8-BIT, AND
  FORWARD REFERENCES, 16-BIT, BUT
  BOTH GENERATE 8-BIT RELATIVE ADRS )
: <REF [
  TOS>A  SEC 2 SBC IMM
  SEC ZHERE SBC ZP  A>TOS ] ;
: REF> HERE@W ;
: <TARGET
  DUPW  HERE@W SWAPW -W NIP -ROT
  1-W ! ;
: TARGET> HERE@ ;
( CONDITIONALS )
: IF PRE>A 0 BEQ REF> ; IMMEDIATE
: DISABLE-TAIL
  0 ZOPTIMIZE @ 7F AND 0 ZOPTIMIZE ! ;
: THEN <TARGET DISABLE-TAIL
  ; IMMEDIATE
: ELSE
  CLC 0 BCC REF>  SWAPW
  TAIL; THEN IMMEDIATE
: CASE
  >A
  STACK CMP ADR,X
  4 BNE
  INX  ' >CODE JMP ; IMMEDIATE
( INLINED WORDS )
: EXIT RTS ; IMMEDIATE
: DROP
  COMPILING IF INX
  ELSE [ INX ] THEN ; IMMEDIATE
: DROPW
  COMPILING IF INX INX
  ELSE [ INX INX ] THEN ; IMMEDIATE
( RETURN STACK 16-BIT OPS )
: DUP>RW
  NOS>A PHA TOS>A PHA ; IMMEDIATE
: R>DROPW PLA PLA ; IMMEDIATE
: >RW 
  NOS>A PHA TOS>A PHA
  INX INX ; IMMEDIATE
: R>W
  DEX DEX
  PLA A>TOS PLA A>NOS
  ; IMMEDIATE
: R@W
  DEX DEX
  PLA A>TOS TAY
  PLA PHA A>NOS
  TYA PHA ; IMMEDIATE
( LITERALS/EXECUTION )
: EXECUTE [
  >A  CLC 3 ADC IMM  0 A>T+
  >A  0 ADC IMM  1 A>T+
  0 ZTEMP JMPI ] ;
: LIT R>W 1+W DUP>RW @ ;
: LITW R>W 1+W DUPW 1+W >RW @W ;
: LETW
  DUPW DUP>RW @W >RW
  !W EXECUTE
  R>W R>W !W ;
( POSTPONE )
: DOCOMPILE
  R>W 1+W DUPW 1+W >RW @W JSR ;
: POSTPONE
  '
  DUPW >FLAGS @ 0< IF
    >CODE JSR
  ELSE
    LITW [ ' DOCOMPILE >CODE ,2 ] JSR
    >CODE ,2
  THEN ; IMMEDIATE
( MAKE AND DYNAMIC RELINKING )
: PATCH
  ' >CODE  DUPW 4C -ROT ! ( JMP )
  1+W HERE@W SWAPW !W  ON COMPILER ;
: DOMAKE
  R>W 1+W DUPW @W SWAPW
  1+W 1+W SWAPW !W ;
( USE ONLY WITH MAKER WORDS )
: >MAKE >CODE 1+W ;
: MAKE
  COMPILING IF
    POSTPONE DOMAKE  ' >MAKE ,2
  ELSE PATCH THEN ; IMMEDIATE
: UNMAKE ' >MAKE
  DUPW 1+W 1+W SWAPW !W ;
: MAKING ' >MAKE ' >CODE SWAPW LETW ;
( LOOPS )
: BEGIN TARGET> ; IMMEDIATE
: AGAIN CLC <REF BCC ; IMMEDIATE
: UNTIL PRE>A <REF BEQ ; IMMEDIATE
: FOR PRE>A  0 BEQ REF>  PHA TARGET>
  ; IMMEDIATE
: FORW NOS>A PHA TOS>A PHA INX INX
  TARGET> ; IMMEDIATE
: NEXT
  PLA  SEC 1 SBC IMM  PHA
  <REF BNE
  PLA
  <TARGET ; IMMEDIATE
: NEXTW
  PLA  SEC 1 SBC IMM A>T
  PLA  0 SBC IMM  PHA  T ORA ZP  TAY
  T>A PHA
  TYA  <REF BNE
  PLA PLA ; IMMEDIATE
: I PLA PHA A> ; IMMEDIATE
: IW PLA A> PLA A> PHA NOS>A PHA
  ; IMMEDIATE
: DO
  NOS>A PHA TOS>A PHA INX INX
  HERE@
  PLA A>T ( T = COUNT )
  PLA  T CMP ZP
  0 BEQ  HERE@W  PHA
  T>A PHA ; IMMEDIATE
: +LOOP
  PLA  CLC STACK ADC ADR,X INX  PHA
  ROT CLC <REF BCC
  TAIL; THEN IMMEDIATE
( INPUT STREAM )
: CHAR
  0 ZINPUT @W 0 ZEND @W =W IF 0 ELSE
    0 ZINPUT @W @
    0 1  0 ZINPUT +!W
  THEN ;
: [CHAR]
  CHAR POSTPONE LITERAL ; IMMEDIATE
: .(
  CHAR DUP [CHAR] ) = IF
    DROP CR EXIT
  THEN EMIT TAIL; .( IMMEDIATE
: # CHAR DUP 0= SWAP 0D = OR
  SKIP TAIL; # IMMEDIATE
( STRINGS )
: S" HERE@W 0 ,
  BEGIN
    CHAR DUP [CHAR] " =
    IF DROP EXIT THEN
    ,  DUPW 1 -ROT +!
  AGAIN ;
: COUNT DUPW 1+W SWAPW  @ ;
: LITS
  R>W 1+W DUPW DUPW @ 0 SWAP +W >RW ;
: DUMP
  DUP 0= IF DROP DROPW EXIT THEN
  -ROT DUPW @ . 1+W ROT  1- DUMP ;
: .S
  SP@ STACK> SWAP
  FC OVER - 3F AND DUMP ;
: " POSTPONE LITS S" DROPW ; IMMEDIATE
: ."
  POSTPONE LITS S" DROPW
  POSTPONE COUNT POSTPONE TYPE
  ; IMMEDIATE
.( COMPILING COMPILER )
: LAST 0 ZLAST ;
: LITERALW POSTPONE LITW ,2 ; IMMEDIATE
: ['] ' POSTPONE LITERALW ; IMMEDIATE
( DOES> )
: HERE>CODE LAST @W >CODE HERE!W ;
: DODOES
  R>W 1+W  LAST @W >CODE 1+W !W ;
: DOES>
  POSTPONE DODOES
  POSTPONE R>W POSTPONE 1+W ; IMMEDIATE
( ADDITIONAL LOOPING CONSTRUCTS )
: CALL-PARENT [
  ZTEMP STXZP  TSX
  01 04 LDA ADR,X  PHA
  01 03 LDA ADR,X  PHA
  ZTEMP LDXZP ] ;
: FOR-EACH
  ?DUP 0= IF R>DROPW DROPW EXIT THEN
  -ROT DUPW 1+W SWAPW @
  CALL-PARENT
  ROT 1- FOR-EACH ;
: TIMES
  ?DUP 0= IF R>DROPW EXIT THEN
  CALL-PARENT
  1- TIMES ;
( DATA STRUCTURES )
: VARIABLE CREATE 0 , ;
: VARIABLEW VARIABLE  0 , ;
: CONSTANT CREATE , DOES> @ ;
: CONSTANTW CREATE ,2 DOES> @W ;
: ALLOT FOR 0 , NEXT ;
: ARRAY
  CREATE ALLOT DOES> ROT 0 SWAP +W ;
: ARRAYW
  CREATE 2* ALLOT DOES>
  ROT 0 SWAP 2*W +W ;
( ADDITIONAL ARITHMETIC )
: << ( X N -- X<<N )
  DUP 0= IF DROP EXIT THEN [
  TARGET>
  STACK> 1 ASL ADR,X
  STACK DEC ADR,X
  <REF BNE
  ] DROP ;
( KERNAL INTERFACE )
VARIABLEW KERNAL-ROUTINE
: KERNAL-CALL [ KERNAL-ROUTINE JMPI ] ;
: KERNAL ( A X Y C W:ADR -- A X Y C )
  KERNAL-ROUTINE !W [
  >A LSR IMPL
  TXA PHA
  3 S>A PHA  TOS>A TAY  NOS>A TAX  PLA
  ] KERNAL-CALL [
  A>T  1 T+ STXZP
  PLA TAX
  TYA A>TOS  1 T+>A A>NOS  T>A 3 A>S
  0 LDA IMM  ROL IMPL  A>
  ] ;
: KERNAL-SETLFS ( FILENO DEV SEC -- )
  0  FF BA KERNAL DROPW DROPW ;
: KERNAL-SETNAM ( W:STR -- )
  COUNT -ROT SWAP 0  FF BD KERNAL
  DROPW DROPW ;
: KERNAL-LOAD
  ( W:START -- W:LAST/ERRNO ERRF )
  0 -ROT SWAP 0  FF D5 KERNAL 
  IF DROPW 1
  ELSE ROT DROP SWAP 0 THEN ;
: KERNAL-GETIN ( -- BYTE )
  0 0 0 0  FF E4 KERNAL  DROPW DROP ;
: KERNAL-SAVE
  ( W:START W:LAST -- ERRNO ERRF )
  SWAP  SWAPW [
  >A ZSAVE STA ZP
  >A ZSAVE 1+ STA ZP
  ] ZSAVE -ROT  0
  FF D8 KERNAL  NIP NIP ;
: KERNAL-KEY
  KERNAL-GETIN ?DUP SKIP KERNAL-KEY ;
: KEY MAKER KERNAL-KEY ;
: SCREEN>PETSCII
  DUP 20 < IF  40 + EXIT  THEN
  DUP 40 < IF  EXIT  THEN
  DUP 60 < IF  80 + EXIT  THEN
  DUP 80 < IF  40 + EXIT  THEN
  DUP C0 < IF  80 - EXIT  THEN
  40 - ;
( KERNAL ADDRESSES )
: NEGATE 0 SWAP - ;
: NEGATEW 0 0 SWAPW -W ;
: -!W SWAPW NEGATEW SWAPW +!W ;
: CODE 0 3 HERE -!W ;
: CURSOR-PHASE 0 CF ;
: CURSOR-ROW-ADR 0 D1 ;
: CURSOR-COL 0 D3 ;
: CURSOR-ROW 0 D6 ;
: CURSOR-DISABLED 0 CC ;
29 ARRAY CODE-BUFFER
: CLS 93 EMIT ;
: CURSOR@ ( -- ROW COL )
  0 0 0 1  FF F0 KERNAL
  DROP  ROT DROP ;
: CURSOR! ( ROW COL -- )
  0 -ROT 0  FF F0 KERNAL
  DROPW DROPW ;
: CURSOR ( ON/OFF -- )
  0= CURSOR-DISABLED !
  ( ENSURE CHAR NOT IN REVERSE MODE )
  CURSOR-ROW-ADR @W
  CURSOR-COL @ 0 SWAP +W
  DUPW @ 7F AND -ROT !
  0  CURSOR-PHASE ! ;
: SCREEN>BUFFER ( W:ADR COUNT -- )
  DUP 0 CODE-BUFFER !
  0 DO
    DUPW @ SCREEN>PETSCII
    I 1+ CODE-BUFFER !
    1+W
  1 +LOOP DROPW ;
: CHECK-STACK
  0 SP@ 0 3 <W IF
    CR ." STACK OVERFLOW" CR  FC SP!
  THEN
  0 SP@ 0 FC >=W IF
    CR ." STACK UNDERFLOW" CR  FC SP!
  THEN ;
: KEY-CURSOR
  ON CURSOR  KEY  OFF CURSOR ;
.( COMPILING EDITOR)
VARIABLEW EDITOR-CURSOR
VARIABLEW EDITOR-END
VARIABLEW EDITOR-PTR
VARIABLE EDITOR-DIRTY
VARIABLEW SOURCE-ADR
: ACTIVE ( W:SOURCE -- )
  SOURCE-ADR !W ;
VARIABLE DEVICE
: TAPE 1 DEVICE ! ;
: DISK 8 DEVICE ! ;
DISK
: SOURCE ( W:ADR -- )
  CREATE DUPW DUPW ,2 ,2 ,2 ;
: SETUP-LOAD/SAVE
  1 DEVICE @ 0 KERNAL-SETLFS
  WORD KERNAL-SETNAM ;
: LOAD-TO ( W:START -- W:END ERR )
  SETUP-LOAD/SAVE KERNAL-LOAD ;
: SAVE-FROM ( W:START W:END -- ERR F )
  SETUP-LOAD/SAVE KERNAL-SAVE ;
: SOURCE-END SOURCE-ADR @W 0 2 +W ;
: SOURCE-OFFSET SOURCE-ADR @W 0 4 +W ;
: SOURCE-START SOURCE-ADR @W ;
: SOURCE-RANGE
  SOURCE-START @W SOURCE-END @W ;
: SOURCE-AT-START
  SOURCE-OFFSET @W SOURCE-START @W =W ;
: SOURCE-AT-END
  SOURCE-OFFSET @W SOURCE-END @W =W ;
: SOURCE-<CHAR
  SOURCE-AT-START SKIP
  0 1 SOURCE-OFFSET -!W ;
: SOURCE-CHAR>
  SOURCE-AT-END SKIP
  0 1 SOURCE-OFFSET +!W ;
: SOURCE@ SOURCE-OFFSET @W @ ;
: SOURCE-<EOL
  SOURCE-<CHAR
  SOURCE-AT-START SKIP
  SOURCE@ 0D = SKIP SOURCE-<EOL ;
: SOURCE-<LINE
  SOURCE-<EOL SOURCE-<EOL
  SOURCE-AT-START SKIP SOURCE-CHAR> ;
: SOURCE-EOL>
  SOURCE-AT-END SKIP
  SOURCE@ 0D = SKIP
  SOURCE-CHAR> SOURCE-EOL> ;
: SOURCE-LINE>
  SOURCE-EOL> SOURCE-CHAR> ;
: TYPE-LINE ( W:ADR -- W:ADR' )
  DUPW SOURCE-END @W =W SKIP
  DUPW 1+W SWAPW @ DUP 0D =
  IF DROP EXIT THEN
  EMIT TYPE-LINE ;
10 ARRAYW LINE-OFFSET
: SOURCE-LIST ( N -- )
  SOURCE-OFFSET @W ROT
  0 DO
    DUPW I LINE-OFFSET !W
    TYPE-LINE CR
  1 +LOOP
  EDITOR-END !W ;
: TYPEW ( W:ADR W:COUNT -- )
  DUPW 0=W IF  DROPW DROPW EXIT  THEN
  SWAPW DUPW @ EMIT  1+W
  SWAPW 1-W TYPEW ;
: TYPE-RANGE OVERW -W TYPEW ;
: EMITS FOR DUP EMIT NEXT DROP ;
: EDITOR-STATUS
  10 0 CURSOR!
  SPACE
  60 8 EMITS
  EDITOR-DIRTY @
  IF [CHAR] * EMIT ELSE SPACE THEN
  SPACE
  SOURCE-START @W
  SOURCE-OFFSET @W OVERW -W .W
  SOURCE-END @W SWAPW -W ." OF " .W
  60 8 EMITS ;
: SAVE-CURSOR
  CURSOR@ EDITOR-CURSOR !W ;
: LOAD-CURSOR
  EDITOR-CURSOR @W CURSOR! ;
: EDITOR-REFRESH
  CLS 10 SOURCE-LIST
  EDITOR-STATUS LOAD-CURSOR ;
: LOAD ( -- )
  SOURCE-START @W LOAD-TO IF
    ." LOAD ERROR " . CR EXIT
  THEN SOURCE-END !W ;
: SAVE ( -- )
  SOURCE-RANGE SAVE-FROM IF
    ." SAVE ERROR" . CR EXIT
  THEN DROP ;
: RUN SOURCE-RANGE INTERPRET ;
: LINE-LENGTH ( W:LAST -- N )
  28 FOR
    1-W DUPW @ 20 <>
    IF DROPW I R>DROP EXIT THEN
  NEXT  DROPW 0 ;
: EDITOR-BUFFER ( -- W:BYTES )
  4 0  0 0  10 FOR
    SWAPW 0 28 +W SWAPW
    OVERW LINE-LENGTH 0 SWAP +W
  NEXT SWAPW DROPW 0 10 +W ;
: MOVE
  >RW OVERW OVERW -W
  DUPW 0<W IF
    DROPW R>W MOVE> EXIT
  THEN
  0<>W IF
    R>W <MOVE EXIT
  THEN
  R>DROPW DROPW DROPW ;
: MOVE-PAGE
  >RW
  EDITOR-END @W  DUPW R@W +W
  SOURCE-END @W EDITOR-END @W -W
  MOVE
  R>W EDITOR-END +!W ;
: CURSOR-OFFSET
  EDITOR-CURSOR @W DROP
  LINE-OFFSET @W ;
: REFOCUS
  CURSOR-OFFSET SOURCE-OFFSET !W
  0 EDITOR-CURSOR 1+W ! ;
: INSERT-LINE
  CURSOR-OFFSET  DUPW 1+W
  SOURCE-END @W OVERW -W  MOVE
  0D CURSOR-OFFSET ! ;
: DELETE-LINE
  EDITOR-CURSOR @W
  DROP 1+ LINE-OFFSET @W
  SOURCE-END @W OVERW -W
  CURSOR-OFFSET SWAPW
  MOVE ;
: RESIZE-PAGE
  SOURCE-OFFSET @W EDITOR-BUFFER +W
  EDITOR-END @W -W
  MOVE-PAGE ;
: PAGE-EMIT
  EDITOR-PTR DUPW @W SWAPW
  0 1 SWAPW +!W  ! ;
: TYPE FOR DUPW @ EMIT 1+W NEXT DROPW ;
: PASTE-PAGE
  SOURCE-OFFSET @W EDITOR-PTR !W
  04 00  10 FOR
    DUPW DUPW 00 28 +W LINE-LENGTH
    FOR
      DUPW @ SCREEN>PETSCII PAGE-EMIT
      1+W
    NEXT DROPW
    0D PAGE-EMIT
    00 28 +W
  NEXT DROPW ;
: SAVE-PAGE
  SOURCE-OFFSET @W EDITOR-BUFFER +W
  SOURCE-END @W >=W
  IF
    PASTE-PAGE
    EDITOR-PTR @W SOURCE-END !W
  ELSE
    RESIZE-PAGE PASTE-PAGE
  THEN
  FALSE EDITOR-DIRTY ! ;
: MAYBE-SAVE-PAGE
  EDITOR-DIRTY @ SO SAVE-PAGE ;
: MIX ( X -- Y ) SBOX> SWAP @ ;
: MIXW ( W:X -- W:Y )
  OVER XOR MIX SWAP OVER XOR MIX ;
: CHECKSUM ( W:ADR W:N -- W:X )
  AB BA SWAPW
  DUPW 0=W IF
    DROPW SWAPW DROPW EXIT
  THEN
  FORW
    OVERW @ XOR MIXW
    SWAPW 1+W SWAPW
  NEXTW SWAPW DROPW ;
: RANGE-CHECKSUM  OVERW -W CHECKSUM ;
: SOURCE-CHECKSUM
  SOURCE-RANGE RANGE-CHECKSUM ;
: KEY-PGUP
  MAYBE-SAVE-PAGE
  10 FOR SOURCE-<LINE NEXT
  EDITOR-REFRESH ;
: KEY-PGDOWN
  MAYBE-SAVE-PAGE
  10 FOR SOURCE-LINE> NEXT
  EDITOR-REFRESH ;
: INSIDE-PAGE CURSOR@ DROP 10 < ;
: INSIDE-PROMPT  CURSOR@ DROP 11 >= ;
: INTERPRET-LINE
  CURSOR-ROW-ADR @W  28
  SCREEN>BUFFER
  1 CODE-BUFFER DUPW
  0 CODE-BUFFER @ 0 SWAP +W
  CR INTERPRET
  INSIDE-PROMPT IF ."  OK" CR THEN ;
: KEY-ENTER
  INSIDE-PROMPT
  IF INTERPRET-LINE CHECK-STACK
  ELSE CR THEN ;
: ARROW-KEY
  7F AND DUP 11 = SWAP 1D = OR ;
: MODIFYING-PAGE
  ARROW-KEY NOT  INSIDE-PAGE  AND ;
: SWITCH-VIEW
  INSIDE-PAGE IF
    MAYBE-SAVE-PAGE
    EDITOR-STATUS
    SAVE-CURSOR  11 0 CURSOR!
  ELSE
    LOAD-CURSOR
  THEN ;
: RUN-FROM
  SAVE-CURSOR
  MAYBE-SAVE-PAGE EDITOR-REFRESH
  CURSOR@ DROP LINE-OFFSET @W
  EDITOR-END @W
  11 0 CURSOR!
  INTERPRET ;
: RLS
  MAYBE-SAVE-PAGE
  EDITOR-CURSOR @W DROP +
  LINE-OFFSET @W
  CURSOR-OFFSET SWAPW
  INTERPRET ;
: FILLW
  >R BEGIN
    OVERW R@ -ROT !  SWAPW 1+W SWAPW
  1-W  DUPW 0=W UNTIL
  DROPW DROPW R>DROP ;
: CLEAR-PROMPT
  SAVE-CURSOR
  EDITOR-REFRESH
  LOAD-CURSOR
  06 A8  01 40  20 FILLW ;
: MAKE-DIRTY
  EDITOR-DIRTY @
  TRUE EDITOR-DIRTY !
  NOT IF
    SAVE-CURSOR
    11 0 CURSOR!  EDITOR-STATUS
    LOAD-CURSOR
  THEN ;
: IL INSERT-LINE EDITOR-REFRESH ;
: ILS FOR INSERT-LINE NEXT
  EDITOR-REFRESH ;
: DL DELETE-LINE EDITOR-REFRESH ;
: DLS FOR DELETE-LINE NEXT
  EDITOR-REFRESH ;
: >BOF
  SOURCE-START @W SOURCE-OFFSET !W
  EDITOR-REFRESH ;
: >EOF SOURCE-END @W SOURCE-OFFSET !W
  EDITOR-REFRESH ;
: EDITOR-KEY
  0D CASE KEY-ENTER
  87 CASE KEY-PGUP
  88 CASE KEY-PGDOWN
  8C CASE EDITOR-REFRESH ( F8 )
  8D CASE SWITCH-VIEW ( SHIFT+ENTER )
  83 CASE RUN-FROM ( RUN/SHIFT+ESC )
  93 CASE CLEAR-PROMPT ( SHIFT+HOME )
  DUP MODIFYING-PAGE IF MAKE-DIRTY THEN
  EMIT ;
: STATUS
  HERE@W ['] ,2 -W
  .W ." BYTES USED" CR ;
: EDITOR
  EDITOR-REFRESH
  ( 17 0 CURSOR!  STATUS  0 0 CURSOR! )
  BEGIN
    KEY-CURSOR EDITOR-KEY
  AGAIN ;
MAKE ERROR ." ERROR #" .
  ." PRESS ANY KEY" KEY DROP EDITOR ;
( TESTING )
: VICE-KEY KERNAL-KEY
  DUP 23 = SO DROP 3B ;
MAKE KEY VICE-KEY ;
: SKIP-INTERPRET
  0 ZEND @W  0 ZINPUT !W ;
: TEST-TYPE FOR-EACH EMIT ;
: TEST-TIMES 8 TIMES DUP . ;
.( DONE )
60 00 SOURCE USER-SOURCE
USER-SOURCE ACTIVE
( PI TEST )
: DATA"
  CHAR DUP [CHAR] " = SKIP
  DUP 20 >= IF , ELSE DROP THEN
  DATA" ;
CREATE PI-DIGITS DATA"
314159265358979323846264338327950288
419716939937510582097494459230781640
628620899862803482534211706798214808
651328230644709384460955058223172535"
HERE@W PI-DIGITS -W CONSTANTW N-DIGITS
VARIABLEW PI-POS
PI-DIGITS PI-POS !W
: PI-DIGIT PI-POS @W @ ;
: JIFFY@W 0 A1 @W SWAP ;
: JIFFYS 0 SWAP JIFFY@W +W
  BEGIN JIFFY@W OVERW >=W UNTIL
  DROPW ;
: ADVANCE 0 1 PI-POS +!W ;
VARIABLE SCORE
: SCORE+!
  SCORE +!
  SCORE @ 0< IF 0 SCORE ! THEN
  CURSOR@  0 0 CURSOR!
  ." SCORE: " SCORE @ .
  CURSOR! ;
: PI-GAME
  KEY DUP 20 = IF
    5 EMIT PI-DIGIT EMIT 9A EMIT
    ADVANCE
    5 NEGATE SCORE+!
  ELSE PI-DIGIT = IF
    PI-DIGIT EMIT  ADVANCE
    1 SCORE+!
  ELSE
    3 NEGATE SCORE+!
    1 D0 20 +!
    10 JIFFYS
    FF D0 20 +!
  THEN
  THEN
  PI-GAME ;
: DUMMY BEGIN [
  8 LDA IMM
  04 00 STA ADR,X  INX
  9 LDA IMM
  04 00 STA ADR,X  INX
  ] ;
( KERNEL-SOURCE ACTIVE )
EDITOR
