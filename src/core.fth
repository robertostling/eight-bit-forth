.( COMPILING)
: ,2 , , ;
: ,3 , , , ;
: 0 00 ;
: 1 01 ;
( USE WITH IMM )
: ORA 0 ;
: ANDA 20 ;
: EORA 40 ;
: ADC 60 ;
: STA 80 ;
: LDA A0 ;
: CMP C0 ;
: SBC E0 ;
( USE WITH IMPL )
: ASL 1 ;
: ROL 21 ;
: LSR 41 ;
: ROR 61 ;
( USE WITH NEITHER )
: DEC C1 ;
: INC E1 ;
( ADDRESSING MODES )
: IMPL 9 + , ;
: IMM 9 + ,2 ;
: ADR D + ,3 ;
: ZP 5 + ,2 ;
: (X) 1 + ,2 ;
: (Y) 11 + ,2 ;
: ZP,X 15 + ,2 ;
: ADR,Y 19 + ,3 ;
: ADR,X 1D + ,3 ;
( BRANCHING )
: BPL 10 ,2 ;
: BMI 30 ,2 ;
: BVC 50 ,2 ;
: BVS 70 ,2 ;
: BCC 90 ,2 ;
: BCS B0 ,2 ;
: BNE D0 ,2 ;
: BEQ F0 ,2 ;
: BRK 00 , ;
: JSR 20 ,3 ; 
: RTI 40 , ;
( RTS HAS BUILT-IN OPTIMIZING WORD )
: JMP 4C ,3 ;
: JMPI 6C ,3 ;
: NOP EA , ;
: JAM 02 , ;
( ZERO-OPERAND INSTRUCTIONS )
: PHP 08 , ;
: CLC 18 , ;
: PLP 28 , ;
: SEC 38 , ;
: PHA 48 , ;
: CLI 58 , ;
: PLA 68 , ;
: SEI 78 , ;
: DEY 88 , ;
: TYA 98 , ;
: TAY A8 , ;
: CLV B8 , ;
: INY C8 , ;
: CLD D8 , ;
: INX E8 , ;
: SED F8 , ;
: TXA 8A , ;
: TXS 9A , ;
: TAX AA , ;
: TSX BA , ;
: DEX CA , ;
( VARIOUS INSTRUCTIONS WITH NON-UNIFORM
  ADDRESSING MODES )
: LDXIMM A2 ,2 ;
: LDXZP A6 ,2 ;
: LDYIMM A0 ,2 ;
: STYZP 84 ,2 ;
: STYZP,X 94 ,2 ;
: LDYZP A4 ,2 ;
: LDYZP,X B4 ,2 ;
: STYADR 8C ,3 ;
: LDYADR AC ,3 ;
: LDYADR,X BC ,3 ;
: STXZP 86 ,2 ;
: STXZP,Y 96 ,2 ;
: STXADR 8E ,3 ;
: CPYIMM C0 ,2 ;
: CPXIMM E0 ,2 ;
: CPYZP C4 ,2 ;
: CPXZP E4 ,2 ;
: CPYADR CC ,3 ;
: CPXADR EC ,3 ;
: BITZP 24 ,2 ;
: BITADR 2C ,3 ;
( CORE COMPILER )
: STACK> CE ;
: STACK-1 CD FF ;
: STACK STACK> 0 ;
: SBOX> CD ;
: ZHERE 2 ;
: ZLAST 4 ;
: ZINPUT 6 ;
: ZEND 8 ;
: ZSTATE C ;
: ZOPTIMIZE D ;
: ZTASK E ;
: ZTEMP 13 ;
: ZSAVE 1E ;
: ZMREG 20 ;
: ZNREG 22 ;
( TEMP ACCESS MACROS )
: T ZTEMP ;
: T+ ZTEMP + ;
: A>T+ T+ STA ZP ;
: T+>A T+ LDA ZP ;
: A>T T STA ZP ;
: T>A T LDA ZP ;
( STACK OPERATIONS AND MACROS )
: SWAP [
  STACK LDA ADR,X
  PHA
  STACK> 1 LDA ADR,X
  STACK STA ADR,X
  PLA
  STACK> 1 STA ADR,X ] ;
( NOTE: 1-BASED ADDRESSING )
: S>A STACK> SWAP FF +  LDA ADR,X ;
: A>S STACK> SWAP FF +  STA ADR,X ;
: >A STACK LDA ADR,X  INX ;
: A> DEX  STACK STA ADR,X ;
( SAME AS >A BUT SETS FLAGS AND COSTS
  1 MORE CYCLE )
: PRE>A INX  STACK-1 LDA ADR,X ;
: TOS>A 1 S>A ;
: A>TOS 1 A>S ;
: NOS>A 2 S>A ; 
: A>NOS 2 A>S ;
: #A>TOS LDA IMM  A>TOS ;
( COMPILER WORDS )
: IMMEDIATE [
  2 LDYIMM
  80 LDA IMM
  ZLAST ORA (Y)
  ZLAST STA (Y) ] ;
: ON FF ;
: OFF 0 ;
: COMPILING [ ZSTATE LDA ZP  A> ] ;
: COMPILER [ >A  ZSTATE STA ZP ] ;
: SO PRE>A 1 BNE RTS ; IMMEDIATE
: SKIP PRE>A 1 BEQ RTS ; IMMEDIATE
( STACK OPERATIONS )
: DUP [ TOS>A A> ] ;
: DROP [ INX ] ;
: OVER [ NOS>A A> ] ;
: OOVER [ 3 S>A A> ] ;
: NIP [ TOS>A A>NOS INX ] ;
: SP@ [ TXA A> ] ;
: SP! [ >A TAX ] ;
: RP@ [
  TXA PHA TSX TXA TAY PLA TAX TYA A>
  ] ;
: RP! [
  TXA TAY  TOS>A TAX TXS
  TYA TAX INX ] ;
: >R >A PHA ; IMMEDIATE
: R> PLA A> ; IMMEDIATE
: R>DROP PLA ; IMMEDIATE
: R@ PLA PHA A> ; IMMEDIATE
: -ROT [
  TOS>A PHA
  NOS>A A>TOS
  3 S>A A>NOS
  PLA 3 A>S ] ;
: ROT -ROT -ROT ;
: ?DUP [ TOS>A  1 BNE  RTS  A> ] ;
: 1+ [ STACK INC ADR,X ] ;
: 1- [ STACK DEC ADR,X ] ;
: 2* [ STACK ASL ADR,X ] ;
: 2/ [ STACK LSR ADR,X ] ;
: 2*W [
  STACK ASL ADR,X
  STACK> 1 ROL ADR,X ] ;
: DUPW OVER OVER ;
: OVERW [ 4 S>A A>  4 S>A A> ] ;
: SWAPW OVERW [
  3 S>A 5 A>S  4 S>A 6 A>S
  TOS>A 3 A>S  NOS>A 4 A>S  INX INX ] ;
( NEEDED EARLY, REST DEFINED BELOW )
: +W [
  CLC
  3 S>A  STACK> 0 ADC ADR,X  3 A>S
  4 S>A  STACK> 1 ADC ADR,X  4 A>S
  INX INX ] ;
( ZERO-PAGE MACROS )
: >ZPW ( ZP -- )
  DUP  >A STA ZP  >A 1+ STA ZP ;
: ZP>W ( ZP -- )
  DUP  1+ LDA ZP A>  LDA ZP A> ;
: +ZPW ( ZP N -- )
  LDA IMM  CLC  DUP ADC ZP  DUP STA ZP
  2 BCC  1+ INC ZP ;
: -ZPW ( ZP N -- )
  OVER LDA ZP  SEC  SBC IMM  DUP STA ZP
  2 BCS  1+ DEC ZP ;
: 1+ZPW ( ZP -- )
  DUP  INC ZP  2 BNE  1+ INC ZP ;
( COMPILER WORDS )
: HERE 0 ZHERE ;
: HERE@ [ ZHERE LDA ZP  A> ] ;
: HERE@W
  [ ZHERE 1 + LDA ZP  A> ] HERE@ ;
: HERE!W [
  >A  ZHERE STA ZP
  >A  ZHERE 1 + STA ZP ] ;
: >CODE 0 3 +W ;
: >FLAGS 0 2 +W ;
: >LAST ;
( USED FOR HOT-SWAPPING, SEE MAKE ) 
: MAKER HERE@W 0 3 +W JMP ; IMMEDIATE
( HANDLE BACKWARD REFERENCES WITH
  CONDITIONAL BRANCHING OPS )
: KERNAL-EMIT [ >A  FF D2 JSR ] ;
: EMIT MAKER KERNAL-EMIT ;
: SPACE 20 EMIT ;
: CR 0D EMIT ;
: HEXDIGIT [
  TOS>A
  0F ANDA IMM
  0A CMP IMM
  2 BCC
  6 ADC IMM
  30 ADC IMM
  A>TOS ] ;
: .H
  DUP 2/ 2/ 2/ 2/ HEXDIGIT EMIT
  HEXDIGIT EMIT ;
: . .H SPACE ;
: .W SWAP .H .H SPACE ;
: = [
  >A  STACK CMP ADR,X  6 BEQ
  00 #A>TOS  RTS
  FF #A>TOS ] ;
( MEMORY MANIPULATION )
: S>TW NOS>A 1 A>T+  TOS>A 0 A>T+ ;
: @ [ S>TW  0 LDYIMM
  T LDA (Y)
  INX A>TOS ] ;
: @W [ S>TW  0 LDYIMM
  T LDA (Y)  A>TOS  INY
  T LDA (Y)  A>NOS ] ;
: ! [ S>TW  INX INX  0 LDYIMM
  >A  T STA (Y) ] ;
: !W ! [ INY  >A  T STA (Y) ] ;
: +! [ S>TW  INX INX  0 LDYIMM
  >A  CLC T ADC (Y)  T STA (Y) ] ;
: +!W +! [
  INY >A  T ADC (Y)  T STA (Y) ] ;
( ARITHMETIC )
: ALUOP ( OP - )
  NOS>A  STACK> SWAP 0 SWAP ADR,X
  INX A>TOS ;
: - [ SEC SBC ALUOP ] ;
( : + [ CLC ADC ALUOP ] ; )
: OR [ ORA ALUOP ] ;
: XOR [ EORA ALUOP ] ;
: AND [ ANDA ALUOP ] ;
: ALUOPW ( OP - )
  DUP
  3 S>A
  STACK> SWAP 0 SWAP ADR,X  3 A>S
  4 S>A
  STACK> SWAP 1 SWAP ADR,X  4 A>S
  INX INX ;
: ORW [ ORA ALUOPW ] ;
: XORW [ EORA ALUOPW ] ;
: ANDW [ ANDA ALUOPW ] ;
: -W [ SEC SBC ALUOPW ] ;
( : +W [ CLC ADC ALUOPW ] ; )
: 1+W [
  STACK INC ADR,X
  3 BNE
  STACK> 1 INC ADR,X ] ;
( COMPARISON OPERATORS )
: TRUE FF ;
: FALSE 0 ;
: COMPOP ( OPCODE -- )
  TOS>A  , 6 ,
  FALSE #A>TOS RTS  TRUE #A>TOS ;
: 0= [ F0 COMPOP ] ;
: NOT 0= ;
: 0< [ 30 COMPOP ] ;
: 0>= [ 10 COMPOP ] ;
: 0<> [ D0 COMPOP ] ;
: 0> DUP 0>= SWAP 0<> AND ;
: 0<= DUP 0< SWAP 0= OR ;
: < - 0< ;
: > - 0> ;
: <= - 0<= ;
: >= - 0>= ;
( : = - 0= ; )
: <> - 0<> ;
: <W -W DROP 0< ;
: >=W -W DROP 0>= ;
: 0=W OR 0= ;
: 0<>W OR 0<> ;
: =W -W 0=W ;
: <>W -W 0<>W ;
: 0<W DROP 0< ;
( WORD HEADER OPERATIONS )
: >NAME
  DUPW 0 2 +W @ 1F AND  DUP >R
  0 SWAP -W  R> ;
: TAIL;
  ' >CODE JMP  OFF COMPILER ; IMMEDIATE
: JUMP ' >CODE JMP ;
: CALL ' >CODE JSR ;
( BACKWARD REFERENCES, 8-BIT, AND
  FORWARD REFERENCES, 16-BIT, BUT
  BOTH GENERATE 8-BIT RELATIVE ADRS )
: <REF [
  TOS>A  SEC 2 SBC IMM
  SEC ZHERE SBC ZP  A>TOS ] ;
: REF> HERE@W ;
: <TARGET
  DUPW  HERE@W SWAPW -W NIP -ROT
  1-W ! ;
: TARGET> HERE@ ;
( CONDITIONALS )
: IF PRE>A 0 BEQ REF> ; IMMEDIATE
: DISABLE-TAIL
  0 ZOPTIMIZE @ 7F AND 0 ZOPTIMIZE ! ;
: THEN <TARGET DISABLE-TAIL
  ; IMMEDIATE
: ELSE
  CLC 0 BCC REF>  SWAPW
  TAIL; THEN IMMEDIATE
: CASE
  >A
  STACK CMP ADR,X
  4 BNE
  INX  ' >CODE JMP ; IMMEDIATE
( INLINED WORDS )
: EXIT RTS ; IMMEDIATE
: DROP
  COMPILING IF INX
  ELSE [ INX ] THEN ; IMMEDIATE
: DROPW
  COMPILING IF INX INX
  ELSE [ INX INX ] THEN ; IMMEDIATE
( RETURN STACK 16-BIT OPS )
: DUP>RW
  NOS>A PHA TOS>A PHA ; IMMEDIATE
: R>DROPW PLA PLA ; IMMEDIATE
: >RW 
  NOS>A PHA TOS>A PHA
  INX INX ; IMMEDIATE
: R>W
  DEX DEX
  PLA A>TOS PLA A>NOS
  ; IMMEDIATE
: R@W
  DEX DEX
  PLA A>TOS TAY
  PLA PHA A>NOS
  TYA PHA ; IMMEDIATE
( LITERALS/EXECUTION )
: EXECUTE [
  >A  CLC 3 ADC IMM  0 A>T+
  >A  0 ADC IMM  1 A>T+
  0 ZTEMP JMPI ] ;
: LIT R>W 1+W DUP>RW @ ;
: LITW R>W 1+W DUPW 1+W >RW @W ;
: (TO) R>W 1+W DUPW 1+W >RW @W ! ;
: (TOW) R>W 1+W DUPW 1+W >RW @W !W ;
: LETW
  DUPW DUP>RW @W >RW
  !W EXECUTE
  R>W R>W !W ;
( POSTPONE )
: DOCOMPILE
  R>W 1+W DUPW 1+W >RW @W JSR ;
: POSTPONE
  '
  DUPW >FLAGS @ 0< IF
    >CODE JSR
  ELSE
    LITW [ ' DOCOMPILE >CODE ,2 ] JSR
    >CODE ,2
  THEN ; IMMEDIATE
( MAKE AND DYNAMIC RELINKING )
: PATCH
  ' >CODE  DUPW 4C -ROT ! ( JMP )
  1+W HERE@W SWAPW !W  ON COMPILER ;
: DOMAKE
  R>W 1+W DUPW @W SWAPW
  1+W 1+W SWAPW !W ;
( USE ONLY WITH MAKER WORDS )
: >MAKE >CODE 1+W ;
: MAKE
  COMPILING IF
    POSTPONE DOMAKE  ' >MAKE ,2
  ELSE PATCH THEN ; IMMEDIATE
: UNMAKE ' >MAKE
  DUPW 1+W 1+W SWAPW !W ;
: MAKING ' >MAKE ' >CODE SWAPW LETW ;
( LOOPS )
: BEGIN TARGET> ; IMMEDIATE
: AGAIN CLC <REF BCC ; IMMEDIATE
: UNTIL PRE>A <REF BEQ ; IMMEDIATE
: FOR PRE>A  0 BEQ REF>  PHA TARGET>
  ; IMMEDIATE
: FORW NOS>A PHA TOS>A PHA INX INX
  TARGET> ; IMMEDIATE
: NEXT
  PLA  SEC 1 SBC IMM  PHA
  <REF BNE
  PLA
  <TARGET ; IMMEDIATE
: NEXTW
  PLA  SEC 1 SBC IMM A>T
  PLA  0 SBC IMM  PHA  T ORA ZP  TAY
  T>A PHA
  TYA  <REF BNE
  PLA PLA ; IMMEDIATE
: I PLA PHA A> ; IMMEDIATE
: IW PLA A> PLA A> PHA NOS>A PHA
  ; IMMEDIATE
: DO
  NOS>A PHA TOS>A PHA INX INX
  HERE@
  PLA A>T ( T = COUNT )
  PLA  T CMP ZP
  0 BEQ  HERE@W  PHA
  T>A PHA ; IMMEDIATE
: +LOOP
  PLA  CLC STACK ADC ADR,X INX  PHA
  ROT CLC <REF BCC
  TAIL; THEN IMMEDIATE
( INPUT STREAM )
: CHAR
  0 ZINPUT @W 0 ZEND @W =W IF 0 ELSE
    0 ZINPUT @W @
    0 1  0 ZINPUT +!W
  THEN ;
: [CHAR]
  CHAR POSTPONE LITERAL ; IMMEDIATE
: .(
  CHAR DUP [CHAR] ) = IF
    DROP CR EXIT
  THEN EMIT TAIL; .( IMMEDIATE
: # CHAR DUP 0= SWAP 0D = OR
  SKIP TAIL; # IMMEDIATE
( STRINGS )
: S" HERE@W 0 ,
  BEGIN
    CHAR DUP [CHAR] " =
    IF DROP EXIT THEN
    ,  DUPW 1 -ROT +!
  AGAIN ;
: COUNT DUPW 1+W SWAPW  @ ;
: LITS
  R>W 1+W DUPW DUPW @ 0 SWAP +W >RW ;
: DUMP
  DUP 0= IF DROP DROPW EXIT THEN
  -ROT DUPW @ . 1+W ROT  1- DUMP ;
: .S
  SP@ STACK> SWAP
  FC OVER - 3F AND DUMP ;
: " POSTPONE LITS S" DROPW ; IMMEDIATE
: ."
  POSTPONE LITS S" DROPW
  POSTPONE COUNT POSTPONE TYPE
  ; IMMEDIATE
( HIGH-LEVEL COMPILER )
: LAST 0 ZLAST ;
: LITERALW POSTPONE LITW ,2 ; IMMEDIATE
: TO POSTPONE (TO) ' 0 6 +W ,2 ; IMMEDIATE
: TOW POSTPONE (TOW) ' 0 6 +W ,2 ; IMMEDIATE
: ['] ' POSTPONE LITERALW ; IMMEDIATE
( DOES> )
: HERE>CODE LAST @W >CODE HERE!W ;
: DODOES
  R>W 1+W  LAST @W >CODE 1+W !W ;
: DOES>
  POSTPONE DODOES
  POSTPONE R>W POSTPONE 1+W ; IMMEDIATE
( ADDITIONAL LOOPING CONSTRUCTS )
: CALL-PARENT [
  ZTEMP STXZP  TSX
  01 04 LDA ADR,X  PHA
  01 03 LDA ADR,X  PHA
  ZTEMP LDXZP ] ;
: FOR-EACH
  ?DUP 0= IF R>DROPW DROPW EXIT THEN
  -ROT DUPW 1+W SWAPW @
  CALL-PARENT
  ROT 1- FOR-EACH ;
: TIMES
  ?DUP 0= IF R>DROPW EXIT THEN
  CALL-PARENT
  1- TIMES ;
( DATA STRUCTURES )
: VARIABLE CREATE 0 , ;
: VARIABLEW VARIABLE  0 , ;
: VAR CREATE , DOES> @ ;
: VARW CREATE ,2 DOES> @W ;
: ALLOT FOR 0 , NEXT ;
: ARRAY
  CREATE ALLOT DOES> ROT 0 SWAP +W ;
: ARRAYW
  CREATE 2* ALLOT DOES>
  ROT 0 SWAP 2*W +W ;
: << ( X N -- X<<N )
  DUP 0= IF DROP EXIT THEN [
  TARGET>
  STACK> 1 ASL ADR,X
  STACK DEC ADR,X
  <REF BNE
  ] DROP ;
